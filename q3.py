import string
import re
import math
import requests

CIPHER = 'ERZCDZXLUPSFCNIFTGGLWBHIZAKLKZSGXOIUALKCLBUPXSFYRRAECRWQBHHKFMNQXYNYEYMEXOKCXIHLGMBPKEXMPYLACPQDHHIOJHLOYJXYZZDBWKDLAUPZAIMQSUTFNOVFSUODYJKZSGXEKEXNQLWVUNVWWJKZAZCXOHBLTSHTMOIXTNJOJLZCWAESPKEXIPDZXUWDZHLKDQHZJSKMIOLKMIPOSGXOIKBMVOJFLUTGXACBYXLAGZHGCBJBYFDZXVNKUDMOSLAUUSFXPGBKTQOIXTNJOJHLOIEHNJOJTHFXWOYTCSPUPIDBEGXWLMQPWBNJOJHZVRWFZQBLAYKBVTSUGWKYNYFZVGPGKYVRWWUACGYJJYLHATKHAMOIXBLUDXTHESWLLGQSKXKXYPBCDLAYAGWKYNSCXQGBWNHTOSLIPKTESFOJBPGNXKIODZXCTDGFVUDGGYUDZXMJKHXIHDZXFGDLXLUYFFSHKLAYTCYTPGWWTHQNVBXGKLAUVRWPUUKKJOCBWLNQELWUTUETHYSLAWWBDRVNKUDBCSJYLQWLAYERSKUEDWKUPNLNLPYXMBGSFLWTSHMCQXSEMQQWHLISSGUYSXXIHDZXUDYNXCFBWPUERAEXKCZVIPMDNMKYFMBCDERGQDZXLYKKYLGMCEYFKFWMKMCESVYXBPGVAMNNOKMIPODHTGXYXMGKUAUDYMMUHYGMUPNSAUNPDHHIGZBWJGWKYCBJTHIOVBHCXWTNTYOUYUSVXNJOAKATKNXUPNOXLGCSVLGNLHNJOEXGQBQHZHSNXFKDLEYDBGMBGBKHZOSFXQJYYTPGEHMLASFZNQQWMUNSNBHIOPVYGNAGANIWTLNIAGNJKLNHKFWKMCVKMLWQYEYKKEBHFOTMYFPGKUDODBYHSJXFKQAHOUVQXHVOJMUKXWWNJKLMBGIZTXCVDUYGXTHLPYFMBGSJUUEUKPCVRLAYKBZTHFCAGNJOAKNTYMLYTCHHWMOLLUPNZTXPONXLVKCXHVRWFIWDAGNJSKLNCDWHZGHALNGXUXIWBKPUUDZXGCBKAWQEFMLANGPHDILAYTSNXLYSLACPKKMBGBAOYTGGNHFDOXHVIEBFGCGYNJOKXUOIXBLUDEHMVFAOCFKFWVTYSWCOZJXMUSGGIHDZXCFOFMCVIGYNJSFZMUOWFMVYEXNQRSOYDOWGACSFXXQXSFYOYJTVNOJTQCPLXLPYGGNQGSKXUONXHKXYTNUEUAUVSEXCHYMGXQELYITMWKNCSFMBCDLACULDXUMZDTWGYNXLIBGPHYSLAHGDLEYUGSLNJOUAOTMZRUTNSGXVRSMJJSDBJRSJKCRVSMYQPLACUZSKCURSGXCVKHAGYJZCCXSPCHOGYNJOSUIXOOXLGNWTXCXVUOTSWWUPNLAUVKDXRCXVXLDKJMBQVGFYYKTKUJKEMIDSSLUPNJHAGBAGZCXLVBKVVKYPYXMBGKXHLGCSBXYOJXUNCGWYCNSGXDEJBYFKFWNJKLMBGNSKEHVSMQKVVXLPOKLVGIGGXVRWVBWBUASCBVBHVOJLYEDWWQKDZWSMOKTHFWGNHFCSGXIKLXMYSLAMEKLMYTOVVUVDDXZGOVBHIYFBNYKKMBGWSKMJOKTHFDZTNVRWEIYVWTXGXDBHGLWRIPNOTMVRWKCXOJTHFDZTNVRWWCUDSGNUKNTAGVSBLHBGFQJSUANJOOBHFGSLLWCZBHIGSLNJOKXUCXVMBCDLAYUWSEFDEFWFGYXLBKFWKMIBGPCPQSYLCSVHZKDSEFCXVUYISFGCPQLHWTIOTMRSHAINNQHOTXGBMGMJBYFKLXLTSTEYXYAVYCCSFUPCLTLVOVNJHBGFUOYFZNJOYKUXOKTNVRWLCFOGYNJOUAOTMZIITMZDYGZKMCNVQHONSLMFGNWOCNYJBFNMMMSQEJMBTYSMUHOSKZWVETHCVDBHEYSKMGQJXSYSLAUIBWTNKBGGIPRALFGQSFUPGAMBPYZTNCXVPCVR'

ENG = 0.0667
RAND = 1/26

# (a)
# Friedman II
def friedmanII(text):
    phi = 0
    # phi = sum(probabilities of each letter)
    for c in string.ascii_uppercase:
        phi += (text.count(c)/len(text))**2
    return phi, len(text)*(ENG-RAND)/((len(text)-1)*phi-len(text)*RAND+ENG)

print(f"estimated key length: {friedmanII(CIPHER)[1]}")






# (b)
# Kasiskiâ€™s test
tri = {}
# count num of occurence for each triple
for i in range(len(CIPHER) - 2):
    tri[CIPHER[i:i+3]] = tri.get(CIPHER[i:i+3], 0) + 1

distance = []
print("\ntext | First occur | Distance to Subsequent Occurences")

# take the top 5 most frequent triples
for t in sorted(tri, key=tri.get)[-5:]:
    # index of all occurences
    occ = [m.start() for m in re.finditer(t, CIPHER)]
    # text | First occur | Distance to Subsequent Occurences
    print(f" {t} |     {occ[0]}     | {[i-occ[0] for i in occ][1:]}")
    distance += [i-occ[0] for i in occ][1:]

# key length = gcd of all Distance to Subsequent Occurences
print(f"\nthe most likely length of the key = {math.gcd(*distance)}")


















# (c)
# Decryption
# 5-letter English words
meaningpedia_resp = requests.get("https://meaningpedia.com/5-letter-words?show=all")
# compile regex
pattern = re.compile(r'<span itemprop="name">(\w+)</span>')
# find all matches
words = [w.upper() for w in pattern.findall(meaningpedia_resp.text)]

# test out each word as keyword
for w in words:
    plain = ''
    for i, c in enumerate(CIPHER):
        # subtract the index of the corresponding keyword character  
        # from the index of the cipher text character
        # modulo 26 to get a valid index in the alphabet
        # add the plaintext character at the index to string
        plain += string.ascii_uppercase[(string.ascii_uppercase
            .index(c)-string.ascii_uppercase.index(w[i%5]))%26]

    # filter the result by comparing its phi value to that of English
    if abs(friedmanII(plain)[0] - ENG) <= 0.005:
        print(f'\nkeyword: {w}\nplain text: {plain}\n')





